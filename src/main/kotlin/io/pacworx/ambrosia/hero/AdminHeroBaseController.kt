package io.pacworx.ambrosia.hero

import io.pacworx.ambrosia.battle.BattleRepository
import io.pacworx.ambrosia.battle.BattleService
import io.pacworx.ambrosia.battle.offline.MissionRepository
import io.pacworx.ambrosia.exceptions.GeneralException
import io.pacworx.ambrosia.fights.FightStageRepository
import io.pacworx.ambrosia.hero.skills.HeroSkill
import io.pacworx.ambrosia.hero.skills.HeroSkillAction
import io.pacworx.ambrosia.hero.skills.SkillActionEffect
import io.pacworx.ambrosia.hero.skills.SkillActionTarget
import io.pacworx.ambrosia.hero.skills.SkillActionTrigger
import io.pacworx.ambrosia.hero.skills.SkillActionType
import io.pacworx.ambrosia.hero.skills.SkillActiveTrigger
import io.pacworx.ambrosia.hero.skills.SkillTarget
import io.pacworx.ambrosia.player.AuditLogService
import io.pacworx.ambrosia.player.Player
import io.pacworx.ambrosia.vehicle.VehicleRepository
import org.springframework.data.repository.findByIdOrNull
import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.CrossOrigin
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.ModelAttribute
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.server.ResponseStatusException
import javax.transaction.Transactional
import javax.validation.Valid

@RestController
@CrossOrigin(maxAge = 3600)
@RequestMapping("admin/hero_base")
class AdminHeroBaseController(private val heroBaseRepository: HeroBaseRepository,
                              private val heroRepository: HeroRepository,
                              private val fightStageRepository: FightStageRepository,
                              private val battleRepository: BattleRepository,
                              private val battleService: BattleService,
                              private val missionRepository: MissionRepository,
                              private val vehicleRepository: VehicleRepository,
                              private val auditLogService: AuditLogService) {

    @GetMapping("")
    fun getHeroBases(): List<HeroBase> = heroBaseRepository.findAll()

    @GetMapping("{id}")
    fun getHeroBase(@PathVariable id: Long): HeroBase = heroBaseRepository.getOne(id)

    @PostMapping("")
    @Transactional
    fun postHeroBase(@ModelAttribute("player") player: Player,
                     @RequestBody @Valid heroBaseRequest: HeroBase): HeroBase {
        val heroClass = heroBaseRequest.heroClass
        val rarity = heroBaseRequest.rarity
        val color = heroBaseRequest.color
        heroBaseRepository.findByHeroClassAndRarityAndColor(heroClass, rarity, color)?.let {
            throw ResponseStatusException(HttpStatus.BAD_REQUEST, "$rarity $color hero of $heroClass already exists")
        }
        if (heroBaseRequest.skills.isEmpty()) {
            val skill = HeroSkill(
                number = 1,
                name = "Default S1",
                icon = "default",
                passive = false,
                skillActiveTrigger = SkillActiveTrigger.ALWAYS,
                initCooldown = 0,
                cooldown = 0,
                target = SkillTarget.OPPONENT,
                description = "Autogenerated S1 dealing a single hit on an opponent",
                maxLevel = 1
            )
            skill.actions = listOf(
                HeroSkillAction(
                    position = 1,
                    trigger = SkillActionTrigger.ALWAYS,
                    triggerChance = 100,
                    type = SkillActionType.ADD_BASE_DMG,
                    target = SkillActionTarget.TARGET,
                    effect = SkillActionEffect.STRENGTH_SCALING,
                    effectValue = 150
                ),
                HeroSkillAction(
                    position = 2,
                    trigger = SkillActionTrigger.ALWAYS,
                    triggerChance = 100,
                    type = SkillActionType.DEAL_DAMAGE,
                    target = SkillActionTarget.TARGET,
                    effect = SkillActionEffect.DEAL_PERCENTAGE,
                    effectValue = 100
                )
            )
            heroBaseRequest.skills = listOf(skill)
        }
        return heroBaseRepository.save(heroBaseRequest)
            .also { auditLogService.log(player, "Create hero base ${it.name} #${it.id}", adminAction = true) }
    }

    @PutMapping("{id}")
    @Transactional
    fun updateHeroBase(@ModelAttribute("player") player: Player,
                       @PathVariable id: Long,
                       @RequestBody @Valid heroBaseRequest: HeroBase): HeroBase {

        val movedSkills = mutableListOf<Pair<Int, Int>>()
        var needUpdate = false
        heroBaseRepository.findByIdOrNull(heroBaseRequest.id)?.let { heroBefore ->
            heroBefore.skills.forEach { skillBefore ->
                heroBaseRequest.skills.find { it.id == skillBefore.id && it.number != skillBefore.number }?.let { movedSkill ->
                    movedSkills.add(skillBefore.number to movedSkill.number)
                }
            }

            needUpdate = movedSkills.isNotEmpty() || heroBefore.skills.size != heroBaseRequest.skills.size || heroBaseRequest.skills.any { skill ->
                heroBefore.skills.find { it.number == skill.number }?.let { skillBefore -> skillBefore.skillActiveTrigger != skill.skillActiveTrigger || skillBefore.maxLevel > skill.maxLevel } == true
            }
        }

        val heroBase = heroBaseRepository.save(heroBaseRequest)

        if (needUpdate) {
            heroRepository.findAllByHeroBase(heroBase).forEach {
                it.recheckSkillLevels()
            }
        }
        auditLogService.log(player, "Update hero base ${heroBase.name} #${heroBase.id}", adminAction = true)
        return heroBase
    }

    @DeleteMapping("{id}")
    @Transactional
    fun deleteHeroBase(@ModelAttribute("player") player: Player,
                       @PathVariable id: Long) {
        val heroBase = heroBaseRepository.getOne(id)
        heroRepository.findAllByHeroBase(heroBase).forEach { hero ->
            fightStageRepository.findStagesContainingHero(hero.id).takeIf { it.isNotEmpty() }?.let {
                throw GeneralException(player, "Cannot delete hero base", "BaseHero #$id cannot get deleted as there are fights configured using it. Fight ids: ${it.distinct().joinToString()}")
            }
            battleRepository.findAllByContainingHero(hero.id).forEach { battleId ->
                battleService.deleteBattle(battleRepository.getOne(battleId))
            }
            missionRepository.findAllByContainingHero(hero.id).forEach { missionId ->
                val mission = missionRepository.getOne(missionId)
                val vehicle = vehicleRepository.getOne(mission.vehicleId)
                heroRepository.findAllById(listOfNotNull(
                    mission.hero1Id?.takeIf { it != hero.id },
                    mission.hero2Id?.takeIf { it != hero.id },
                    mission.hero3Id?.takeIf { it != hero.id },
                    mission.hero4Id?.takeIf { it != hero.id }
                )).forEach { it.missionId = null }
                vehicle.missionId = null
                missionRepository.delete(mission)
            }
            hero.unequipAll()
            heroRepository.delete(hero)
        }
        auditLogService.log(player, "Deleted hero base ${heroBase.name} #${heroBase.id}", adminAction = true)
        heroBaseRepository.delete(heroBase)
    }
}
